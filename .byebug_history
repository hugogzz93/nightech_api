exit
date
params[:date]
c[2]
c[3]
c.[3]
c.count
c = Reservation.all.collect { |r| r.date }
Reservation.all.collect { |r| r.date }
Reservation.all
Reservation.by_date(date)
params[:date]
params[:Date]
date
n
params[:date]
exit
DateTime.new(2015, 06, 13).utc
@date.utc.to_s
@date.utc
@date = DateTime.new(2015, 06, 13)
params[:date]
exit
DateTime.parse(params[:date])
DateTime.new(params[:date])
params[:date]
abort
aborty
params[:date].utc
params[:date].class.name
params[:date]
exit
params[:date].class.name
params[:date]
DateTime.new(params[:date])
DateTime.parse(params[:date])
exit
json_response[:reservations].count
json_response[:reservations]
json_response
abort
aborty
Reservation.where(date: date..date.end_of_day).count
Reservation.where(date: date..date.end_of_day)
where('extract(day from date_column) = ?', date.day)
date.day
date
abort
user_response
abort
user_response[:users]
user_response
abort
user_response[:user][:email]
user_response
abort
c
representative_response[:name]
c
current_user.credentials
current_user
abort
@otherUser.credentials
@otherUser
c
current_user.credentials
current_user
abort
@otherUser.credentials
@otherUser
c
representative.belongs_to?(current_user)
current_user.credentials
c
Representative.all.count
c
representative_response[:representatives].count
representative_response[:representatives]
representative_response
Representative.all.count
c
Representative.all.count
Representative.all
n
Representative.all
abort
representative_response
abort
representative_response[]
abort
@user.subordinates.count
@user.subordinates
@user
user_response[:users]
user_response
exit
@deletee.belongs_to? @user
@user.supervisor
@user.subordinates
@user
@deletee.supervisor
@user.subordinates
@user
@deletee
abort
current_user
c
@deletee.supervisor
@user
@deletee
c
abort
user.belongs_to?(current_user)
current_user.subordinates
current_user
authorized_for_user_deletion(current_user, user)
c
@deletee.belongs_to?(@user)
c
authorized_for_user_deletion(current_user, user)
current_user
c
@user.credentials
@user
abort
@user
n
@user
c
user
c
user
current_user
abort
deleter
abort
user_response[:us
user_response
n
user_response
c
updated_attributes
n
current_user.credentials
abort
c
user_response
n
@user.credentials
@user
c
updated_attributes
n
abort
current_user.credentials
current_user
abort
params.has_key?(:userer)
params.has_key?(:user)
params.class.name
params.has_hey?(:user)
params
params[:dog].any?
params[:user].any?
params[:user]
params
updated_attributes
n
c
updatee.class.name
updater.class.name
updater
continue
c
updatee.class.name
updater.class.name
updater
abort
self_update_user_params.empty?
abort
user_params
user.update(self_update_user_params)
user.update(self_update_user_params(
self_update_user_params
abort
aborrt
c
self_update_user_params
user
c
exit
@new_user.supervisor.present?
@new_user.supervisor.id
@new_user.belongs_to?(@user)
@new_user
@user
abort
current_user.outranks? user
abort
user_response
abort
self.errors.any?
self.errors
self
abort
user.valid?
user.errors.any?
user
c
user
c
user.errors
user.errors.any?
user
n
user
current_user.credentials
user.credentials
user
current_user.credentials
c
current_user.credentials
c
current_user.credentials
c
current_user.credentials
current_user
c
current_user.credentials
user
n
c
user
n
user
abort
user.errors.any?
user.errors
user
n
abort
user.errors.any?
user.errors
user
user.errors.add(:credentials, "Insufficient priviledges")
user.errors.add(:credentials, "Insufficient priviledges") unless creating_user.outranks?(new_user)
user.errors.any?
user.errors
user
n
user
abort
user_response
abort
current_user.can_create?(user_params)
current_user
