exit
json_response[:reservations][0][:table]
json_response[:reservations][0]
json_response[:reservations][1]
json_response[:reservations].count
json_response[:reservations]
json_response
c
json_response
exit
reservation_response
exit
@reservation.accepted?
@reservation.reload!
@reservation.reload
@reservation.reload!
@reservation.accepted?
c
n
service.new_record?
n
reservation.status
reservation
exit
service.new_record?
if service
service == Service.first
service
Service.first
Service.all
service.errors
service.valid?
service
n
service
exit
@reservationex
json_response
@reservation
Service.all
c
Service.all
c
Service.all
c
Service.all
c
Service.all
c
Service.all
exit
Service.all
c
@reservation
c
json_response
@reservation
c
@reservation
c
@reservation
exit
Service.all
json_response
exit
json_response
exit
Service.all
Table.all
@table
json_response
exit
json_response
exit
table
exit
table
administrator
exit
Service.by_date(date)
date
Table.all
Service.all
self.errors.messages
self.errors.messages.all
self.errors.messages
self.errors
self.errors.message
self.errors
self.valid?
exit
date
c
date
c
date
c
date
exit
@service
exit
                                                 coordinator: @userexit
FactoryGirl.build :service, administrator: @user,
@service
exit
c
exit
authorized_for_res_deletion(administrator, Reservation.first)
user
administrator.class.name
administrator.class
administrator
Authorizable::has_clearance?(administrator, "administrator")
has_clearance?(administrator, "administrator")
administrator
exit
user_response[:errors][:email].include? "can't be blank"
user_response[:errors][:email].include? "blank"
user_response[:errors][:email]
user_response[:errors][:email].class
user_response[:errors][:email]
user_response
exit
reservation_response[:errors][:quantity].class.name
reservation_response[:errors][:quantity].includes?
reservation_response[:errors][:quantity]
reservation_response[:errors]
exit
json_response
exit
json_response
exit
date
params[:date]
c[2]
c[3]
c.[3]
c.count
c = Reservation.all.collect { |r| r.date }
Reservation.all.collect { |r| r.date }
Reservation.all
Reservation.by_date(date)
params[:date]
params[:Date]
date
n
params[:date]
exit
DateTime.new(2015, 06, 13).utc
@date.utc.to_s
@date.utc
@date = DateTime.new(2015, 06, 13)
params[:date]
exit
DateTime.parse(params[:date])
DateTime.new(params[:date])
params[:date]
abort
aborty
params[:date].utc
params[:date].class.name
params[:date]
exit
params[:date].class.name
params[:date]
DateTime.new(params[:date])
DateTime.parse(params[:date])
exit
json_response[:reservations].count
json_response[:reservations]
json_response
abort
aborty
Reservation.where(date: date..date.end_of_day).count
Reservation.where(date: date..date.end_of_day)
where('extract(day from date_column) = ?', date.day)
date.day
date
abort
user_response
abort
user_response[:users]
user_response
abort
user_response[:user][:email]
user_response
abort
c
representative_response[:name]
c
current_user.credentials
current_user
abort
@otherUser.credentials
@otherUser
c
current_user.credentials
current_user
abort
@otherUser.credentials
@otherUser
c
representative.belongs_to?(current_user)
current_user.credentials
c
Representative.all.count
c
representative_response[:representatives].count
representative_response[:representatives]
representative_response
Representative.all.count
c
Representative.all.count
Representative.all
n
Representative.all
abort
representative_response
abort
representative_response[]
abort
@user.subordinates.count
@user.subordinates
@user
user_response[:users]
user_response
exit
@deletee.belongs_to? @user
@user.supervisor
@user.subordinates
@user
@deletee.supervisor
@user.subordinates
@user
@deletee
abort
current_user
c
@deletee.supervisor
@user
@deletee
c
abort
user.belongs_to?(current_user)
current_user.subordinates
current_user
authorized_for_user_deletion(current_user, user)
c
@deletee.belongs_to?(@user)
c
authorized_for_user_deletion(current_user, user)
current_user
c
@user.credentials
@user
abort
