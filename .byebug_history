c
Service.all
Service.first
status
self.incomplete?
self
incomplete?
c
current_user.organization
current_user.organizationk
Service.first.organization
Service.first.client
n
c
@otherService.client
@otherService.organization
n
@otherService.organization
n
c
@user
@service_attributes["administrator"]
@service_attributes["coordinator"]
@otherService.organization
@otherService
n
c
service.valid?
service
n
service.valid?
service.date
service
n
service
c
@service_attributes["date"] == @otherService.date
@otherService.date
n
@date
@otherService
@otherService.date
@service_attributes["date"]
@service_attributes.date
@service_attributes
@service
c
Service.by_date(date, "day").where(table_id: table.id).first
Service.by_date(date, "day").where(table_id: table.id).first.status
Service.by_date(date, "day").where(table_id: table.id)
Service.by_date(date, "day").count
Service.by_date(date, "day")
c
params
service_update_params
c
self
self.seated_time
seated_time
n
seated_time
status
status_was
c
status
status_was
status_Was
c
status
status_was
status_changed?
changed
c
client
client_was
changed
changed?
status_changed?
c
changed?
status_changed?
status_was
status
changed?
dirty?
status_changed?
status.dirty?
status_was
status
complete?
completed?
seated?
self.update(seated_time: DateTime.now)
DateTime.now
self
exit
c
l
b = (l || d)
b = l || d
d = 1
params[:car]
exit
[@service3, @service4, @service5].collect {|x| x.id}
a.collect {|x| x.id}
a.count
a = Service.by_date(@date, "year")
c
a.count
b = [@service3, @service4, @service5]
a = Service.by_month(@date)
exit
@date + 2
@date + 1
@date
@service5.date
@service5.id
b.collect {|x| x.id}
a.collect { |x| x.id}
b = [@service3, @service4, @service5]
a = Service.by_month(@date)
exit
Service.by_date(a.date)
a.date
Service.by_date(a.date).first.date.beginning_of_day == a.date.beginning_of_day
Service.by_date(a.date).first.date.beginning_of_day = a.date.beginning_of_day
Service.by_date(a.date).first.date
Service.by_date(a.date).first
Service.by_date(a.date)
@service1.date.end_of_day
@service1.date.beginning_of_day
@service1.date.beginning_of_date
a.date
@service1.date
@service1.id
@service2.id
b.first.id
b.id
b = Service.by_date(a.date)
a.table.occupied?(a.date)
a.table
a.errors
a = @service3
@service3.valid?
@service3
a
@service3 = FactoryGirl.build :service, date: @date, table: @table1
@service3 = FactoryGirl.create :service, date: @date, table: @table1
@date
@service2.date
c
request.headers['Authorization']
request.headers
request.headers['Authorization']
current_user
response.auth_token
request.auth_token
response
current_user
params[:user]
user
current_user
updated_attributes
n
user
n
c
params
user
c
n
fields[:current_user]
c
request.path
request
current_user
fields[:current_user]
fields
c
current_user
fields
LogStasher.add_custom_fields do |fields|
LogStasher.add_custom_fields
LogStasher
LogStasher.enabled?
c
respond_with reps
reps
c
Representative.all.where(organization: current_user.organization)
Representative.all
c
c = a ? 3 : nil
b = 2
a = 1
reservation.representative.id
reservation.user
reservation.client
c
n
reservation.organization
table
administrator
reservation
exit
@user_response[:users][-1][:email]
@user_response[:users][0][:email]
@user_response[:users].collect { |x| x.email }
@subordinate_users.collect { |x| x.email }
@user_response[:users][0]
@user_response[:users]
@subordinate_users.count
@subordinate_users
n
exit
@existing_user.organization
@user_response[:organization]
@user_response
c
@user_attributes["credentials"] = "coordinator"
@user_attributes["credentials"]
c
@user_attributes
exit
@user_response[:users].count
@user_response
c
User.where(organization: current_user.organization).where.not(id: current_user.id).count
current_user.super?
c
User.where(organization: current_user.organization).where.not(id: current_user.id).count
current_user.super?
exit
User.where(organization: current_user.organization).where.not(id: current_user.id).count
User.where(organization: current_user.organization).where.not(id: current_user.id)
User.where(organization: current_user.organization).where.not(user_id: current_user.id).count
User.where(organization: current_user.organization).where.not(user_id: current_user.id)
User.where(organization: current_user.organization).count
User.where(organization: current_user.organization).collect { |x| x.organization.name }
User.where(organization: current_user.organization).collect { |x| x.organization }
User.where(organization: current_user.organization).count
User.where(organization: current_user.organization)
current_user.super?
n
service
n
c
@service
n
c
@service
c
@service
c
service.valid?
c
